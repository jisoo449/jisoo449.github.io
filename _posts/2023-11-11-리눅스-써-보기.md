---
layout: post
title: 리눅스 써 보기
author: 박지수
categories: 리눅스
---

### 1. vi 에디터
유닉스 환경에는 vi, gedit, nano 등이 있다. 이 vi 에디터를 일반적으로 많이 사용한다.   
VI 에디터는 1976년도에 개발된 프로그램이다. 그 당시에는 마우스를 사용한 입력이 상용화되지 않았기 때문에 키보드로 모든 것을 처리해야 했다.
이러한 환경에서 개발된 VI에디터는 몇 개의 명령어만을 사용하여 현재 마우스로 할 수 있는 거의 모든 동작을 수행할 수 있도록 도와주었다.
vi에디터에 익숙해지면 키보드에서 손을 떼지 않고 모든 작업을 할 수 있다는 장점이 있다.  

VI 에디터는 아래의 과정을 거쳐 사용하게 된다.  

![image](https://github.com/jisoo449/TIL/assets/48276691/4a327ee9-9622-461d-bcd8-199d3565d225)

1. <code>vi {파일명}</code>를 입력하여 vi 에디터로 들어가기  
   만약 파일이 존재한다면 해당 파일을 열 것이고, 파일이 존재하지 않는다면 새로운 파일을 만들 수 있는 창을 띄워준다.  
   
2. 명령모드에서 입력 모드로 변경    
   처음 vi를 사용해 편집기에 접속하면 명령모드로 접속하게 된다. i를 입력하면 insert 모드, a를 입력하면 append 모드로 들어가게 된다.   
   - insert 모드: 삽입 모드. 현재 커서가 올라간 위치에서부터 입력이 시작된다.  
   - append 모드: 덧붙임. 현재 커서의 뒤에서부터 입력이 시작된다.  
   
3. 명령모드로 되돌아오기  
   esc를 누르면 명령 모드로 되돌아오게 된다.  
   
4. <code>:wq!</code>를 입력하여 에디터 종료하기  
   명령모드에서 : 를 입력하여 라인 입력 모드로 들어간다.
   여기서 w, q, i 등을 수행한다.
   뒤에 !를 덧붙여 주어야지만 해당 명령을 수행한다.  
   
이 밖에도 명령모드에서 입력할 수 있는 다양한 명령어가 존재한다.  

|명령어|설명|
|-------------------|------------------------|
| shift+a | 커서 맨 뒤로 가기 |
|dd / 숫자+dd|현재 커서에서 아래까지 숫자줄 만큼 지움|
|shift+방향|방향키 방향으로 커서 이동|
|yy / 숫자+yy|현재 커서가 있는 행을 복사 및 숫자만큼의 행을 복사|
|p|복사한 내용을 현재 행 이후에 붙여넣기|
|shift+p|복사한 내용을 현재 행 이전에 붙여넣기|

<br/>

### 2. 권한 
#### 2.1. 접근 권한 코드
리눅스에 접속하여 <code>ls -al {파일명 혹은 디렉토리 경로}</code>를 입력하면 해당 파일 혹은 디렉토리 내의 파일들의 권한을 보여준다.
![image](https://github.com/jisoo449/TIL/assets/48276691/22a0aba5-cbf4-4fc9-a586-d28cfc3799ae)  
위 사진을 살펴보자. 맨 앞에 적힌 -, r, w, x 등과 같은 글자로 이루어진 문자열은 파일의 접근 권한을 나타낸다.  

위 사진에 적힌 문자열은 세 문자씩 사용자 계층이 나뉜다. 이러한 사용자 계층은 파일에 접근할 수 있는 사용자의 정보로 나뉜다. 
파일의 권한을 가질 수 있는 그룹은 **소유자(User), 그룹(Group), 기타 사용자(Other)** 이렇게 세 계열로 나뉜다.  
![파일의 접근 권한](https://jisoo449.github.io/jisu_sec/assets/images/post/파일접근권한.png)

위와 같은 사용자들은 읽기(r), 쓰기(w), 만들기(x) 의 권한을 가질 수 있다. 즉, 세 글자 안에는 차례대로 <code>rwx</code>가 들어갈 수 있는 것이다.  
**이 아홉자리의 문자열은 세 자리 숫자로 쓸 수 있다.** 문자열 세 개는 각각 2의 2승, 2의 1승, 2의 0승으로 나뉘며, 문자가 적혀 있다면 1, 그렇지 않다면 0으로 친다. 이 세 개의 문자열 세트를 숫자로 변환하는 것이다. 
예시를 보며 더 자세히 파악 해 보자.  
> <code>-rw-r--r--</code>: 644. 파일의 소유자는 해당 파일을 읽고 쓸 수 있고, 같은 그룹에 속하는 사용자나 그 외 사용자는 해당 파일을 읽는 것만 가능하다.  
> <code>-rwxr-xr-x</code>: 755. 파일의 소유자는 읽고, 쓰고, 생성이 가능하며, 같은 그룹에 속하는 사용자나 그 외는 읽고 생성하는 것만 가능하다.  


#### 2.2. 권한 관련 명령어
- <code>chmod {숫자} {파일명}</code>  
    특정 파일이나 폴더의 소유권 및 접근 권한을 수정한다. 이 방법은 접근 권한을 숫자로 표현한 것 으로, <code>chmod {g/o}{+/-}{r/w/x} {파일명}</code> 처럼 알파벳과 기호를 사용하는 방법도 있다.

- <code>chown {타겟사용자} {파일명}</code>  
    파일 소유자를 변경한다.

- <code>adduser {사용자이름}</code>  
  일반 유저 상태에서는 해당 명령어 사용이 불가하므로 앞에 sudo를 붙여 관리자 모드로 실행한다. 
  ![image](https://github.com/jisoo449/TIL/assets/48276691/3612377c-19a9-4424-8d78-68e344a3b812)
  이후 <code>sudo cat /etc/shadow/</code>를 입력해 추가한 사용자를 확인한다.  
  
- <code>passwd {사용자이름}</code>  
  사용자의 비밀번호를 변경한다.  
  
- <code>usermod --groups ubuntu newuser1</code>  
  사용자의 속성을 변경한다. 이 방법 외에도 passwd 파일을 관리자 권한으로 열어서 groupId의 번호를 바꿔주는 방식으로도 속성 변경이 가능하다.  
  
- <code>userdel {사용자이름}</code>  
  사용자를 삭제하는 명령어이다. 하지만 해당 명령어를 수행하고도 home 디렉토리 밑에는 여전히 해당 사용자의 디렉토리가 남아있다.
  <code>ls -al</code>을 통해 디렉토리 정보를 확인하면 1001번 권한만 있고 사용자 이름은 없는 것을 확인할 수 있다.  
  
- <code>change -{옵션} {숫자} {사용자이름}</code>  
  사용자 암호를 주기적으로 변경하도록 설정 


#### 2.3. 사용자 정보 저장 위치
**- /etc/passwd**  
/etc/passwd 위치에는 사용자 정보가 저장되어 있다.  
<code>vi /etc/passwd</code>를 통해 해당 디렉토리 파일 안을 살펴보면 시스템에 등록된 사용자들의 정보를 확인할 수 있다. 해당 파일을 사용하여 사용자의 계정과 인증을 관리하게 된다.  
![image](https://github.com/jisoo449/TIL/assets/48276691/4a25a5c1-6909-4414-bd8c-e6365a8d88e1)  
각 필드는 콜론으로 구분되며, 다음과 같은 의미를 가진다.  

|필드|설명|
|-------|-------------------|
|사용자 계정명|root나 등록한 사용자 계정명을 나타낸다|
|패스워드|비밀번호를 의미하며, x는 사용자의 패스워드가 /etc/shadow에 암호화되어 저장되어 있다는 뜻이다.|
|UID|사용자의 user id를 나타낸다. 관리자(root)의 UID는 0이다.|
|GID|사용자의 group id를 나타낸다. 관리자 그룹(Root)의 GID는 0이다.|
|comment|사용자와 관련된 기타 정보로, 일반적으로는 사용자의 이름을 저장한다.|
|홈 디렉토리|사용자의 홈 디토리를 의미한다. 해당 계정으로 처음 컴퓨터에 접속 시 해당 위치로 들어가게 된다.|
|로그인 쉘| 사용자가 로그인 할 때(프로그램에 접속 할 때 마다) 필요한 쉘이다. |

**- /etc/shadow**  
/etc/shadow 에서는 사용자의 암호를 볼 수 있다. /etc/shadow 디렉토리의 권한을 살펴보고 각 필드를 보며 의미를 알아보자.  
![image](https://github.com/jisoo449/TIL/assets/48276691/16168aaa-0871-42b4-8f0a-0ea6a2e0296d)  
/etc/shadow 는 root만이 해당 파일에 대한 접근 권한을 가진다는 것을 알 수 있다.   
일반 사용자 모드에서 해당 파일을 조회하면 permission denieed가 뜬다. 이 파일에 접근하려면 sudo 명령어를 사용해야 한다.  
![image](https://github.com/jisoo449/TIL/assets/48276691/5bc82479-fb90-471a-ab87-07266d5dd665)  
각 필드는 컬럼으로 구분되며, 다음과 같은 의미를 가진다.  

|필드|설명|
|-------|-------------------|
|사용자 계정명|root나 등록한 사용자 계정명을 나타낸다|
|암호화된 패스워드|암호화된 패스워드 의미하며, 각 필드는 다시 $ 로 구분된다.<br/> <code>$algorithm_id$salt$encrypted_password</code> <br/> algorithm_id : 암호학적 해시의 id를 의미(ex.MD5, SHA-512) <br/> salt : 각 해쉬에 첨가할 랜덤값으로, 이 랜덤값에 따라서 해시의 값이 바뀐다. <br/> encrypted_password : 마지막은 알고리즘과 salt로 패스워드를 암호화한 값<br/> 이 외에도 *(패스워드 잠김. 별도 인증방식으로만 로그인 가능), !(패스워드 잠김. 로그인 불가), empty(패스워드 설정 안됨. 로그인 가능) 또는 빈 값이 설정될 수 있다. |
|마지막 변경|마지막으로 패스워드를 변경한 날을 1970년 1월 1일 기준으로 일수도 표시|
|패스워드 최소 사용기간|패스워드를 변경한 이후 최소 이 정도의 기간은 써야한다는 것을 의미. 해당 기간 전에는 암호 변경 불가.|
|패스워드 최대 사용기간|마지막 패스워드 변경 이후 만료일수. 90일 권|
|경고|패스워드 만료 이전에 경고할 경고 일수|
|비활성화|패스워드 만료 후 계정이 잠기기 전까지 비활성 일수. 이 기간 내에 암호를 변경해야 계정이 잠기지 않는다.|
|만료일|계정 만료일으 1970년 1월 1일 기준으로 일수로 표시|


### 3. 백업
파일을 압축하고 이를 cron tab을 사용해 백업하는 실습을 해 보자.
#### 3.1. 파일 압축
리눅스에서는 <code>tar</code> 명령어를 사용하여 파일을 압축, 압축해제 한다.  
이 명령어를 사용해 다양한 확장자를 가진 파일을 만들 수 있다.  

|확장자|설명|
|-------------------|-----------------------------------------------|
|.tar|쉬운 공유나 백업을 위해 디렉토리와 그 안의 파일들을 묶어 아카이빙하는 확장자이다.|
|.xz|XZ Util로 파일을 압축할 때 생기는 확장자이다. XZ Util은 Unix 및 Microsoft Window 5.0 이상 버전을 위한 데이터 압축기이다. 여타 압축기에 비해 훨씬 높은 압축률을 자랑한다.|
|.gz|gzip이라는 파일 형식으로, 파일 압축 및 해제에 사용되는 확장자이다.|

파일 압축은 크게 두 단계로 나뉜다.

1. 파일 아카이빙(파일 모으기)
>    <code>tar cvf {압축될파일명.tar} {압축할파일}</code>

2. 파일 압축
>    <code>xz {파일명.tar}</code>


이러한 두 과정을 tar 명령어의 옵션에서 z를 추가하면 파일 모으기와 압축을 함께 할 수 있다.
> <code>tar cvzf {압축될파일명.tar.gz} {압축할 파일}</code>


파일 압축을 해제하려면 tar의 c 옵션을 x로 바꿔주면 된다.
> <code>tar xvzf {압축풀파일}</code>


#### 3.2. 백업
백업은 자동화가 필요하다. 만약 자동화가 되어 있지 않다면 주로 백업이 실시되는 주말이나 오후 6시(제일 접속자가 적은 시간)에도 출근하여 백업을 진행해야 할 것이다. 
다행히도 리눅스에는 cron이 있다.  <br/><br/>
cron이란 Unix계열 운영체제의 작업 스케줄러이다. cron을 사용하면 반복적인 작업을 예약하여 고정된 시간, 날짜 또는 간격에 따라 주기적으로 작업이 실행되도록 할 수 있다.<br/><br/>
cron의 작업은 etc 디렉토리 아래에 있는 crontab(cron 테이블. 예약된 동작을 실시하는 셸 명령을 지정하는 구성 파일) 파일에 의해 구동된다.
```
# ┌───────────── 분 (0–59)
# │ ┌───────────── 시간(0~23)
# │ │ ┌───────────── 날짜(1~31)
# │ │ │ ┌───────────── 월(1~12)
# │ │ │ │ ┌───────────── 요일(0~6)(일요일~토요일,
# │ │ │ │ │ 7은 일부 시스템에서는 일요일이기도 합니다.
# │ │ │ │ │
# │ │ │ │ │
# * * * * * <실행할 명령>
```
각 줄의 구문에는 명령 실행 시간을 나타내는 5개의 필드로 구성된 cron 표현식과 실행할 쉘 명령어로 구성된다. 일반적으로 시간/날짜 지정 필드가 모두 현재 시간 및 날짜와 일치할 때 작업이 실행된다.


다음 문제를 풀어 cron의 사용법에 익숙해 져 보자. 

<b>문제.</b> cron을 사용하여 매 5분마다 /etc 디렉토리를 현재 디렉토리 아래에 시간이름으로 백업하라

<b>해결 방법.</b>
1. 백업 쉘 스크립트 작성  
  <code> vi bakup.sh</code>  
  ```
  #!bin/bash
  today=$(date+%Y%m%d)
  tar cvzf /home/jisoo/etc-$today.tar.gz /etc
  ```
*주의!* 쉘 스크립트 프로그래밍은 띄어쓰기 규칙을 잘 지켜주어야 한다.

2. 작성한 쉘 스크립트 권한 변경  
  <code>chmod 755 backup.sh</code>

3. crontab에 작업 예약  
<code>vi /etc/crontab</code>로 crontab 연 후 파일 맨 하단에 아래 코드 추가
```
5/* * * * *   root    /home/jisoo/backup_etc/bakup.sh
```

4. ps 명령어를 통해 파일이 실행되는 것을 확인한다.
  <code>ps -ef  | grep “cron”</code>

etc 밑에는 cron.d, cron.daily, cron.houly 등과 같이 주기별로 cron 명령어를 실행하는 디렉토리가 나누어져 있다.
만약 악성코드를 발견했다면 해당 프롤그램을 삭제하는 것 뿐만 아니라 crontab을 살펴보는 것도 필수적인 과정이다. <br/><br/>
리눅스에서는 크론탭에 악성코드를 심어놓는 방식으로 해킹을 실시한다. 암호화폐 채굴 등의 목적으로 실행되며, 이 때 오버헤드가 발생하게 된다.<br/><br/>


### 4.5. 기타 명령어
